<!DOCTYPE html>
<html>

<head>
    <title>Moving WebGL Triangle</title>
    <style>
        canvas {
            border: 1px solid black;
        }

        #fps {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 3px;
            font-family: monospace;
        }

        #controls {
            position: fixed;
            top: 50px;
            left: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 3px;
            font-family: monospace;
        }

        label {
            display: block;
            margin: 5px 0;
        }
    </style>
</head>

<body>
    <div id="fps">FPS: 0</div>
    <div id="controls">
        <label>
            cameraAngle:
            <input type="range" id="cameraAngleControl" min="0" max="360.0" step="0.1" value="30.0">
            <span id="cameraAngleValue">0.0</span>
        </label>
        <label>
            fieldOfView:
            <input type="range" id="fieldOfViewControl" min="0" max="180.0" step="0.1" value="30.0">
            <span id="fieldOfViewValue">0.0</span>
        </label>
    </div>
    <canvas id="glCanvas" width="640" height="480"></canvas>
    <script type="module">

        import {setColors, degToRad, m4, getXYRotation, set3DGeometry, setRectangle} from "./math/utils.js";

        import {loadShader, initShaderProgram, compileShader} from "./webgl/mod.js";

        class FPSCounter {
            constructor() {
                this.fps = 0;
                this.frames = 0;
                this.lastTime = performance.now();
                this.element = document.getElementById('fps');
            }

            update() {
                this.frames++;
                const currentTime = performance.now();
                const elapsed = currentTime - this.lastTime;

                if (elapsed >= 1000) {
                    this.fps = Math.round((this.frames * 1000) / elapsed);
                    this.frames = 0;
                    this.lastTime = currentTime;
                    this.element.textContent = `FPS: ${this.fps}`;
                }
            }
        }

        async function main() {
            const canvas = document.querySelector("#glCanvas");
            const gl = canvas.getContext("webgl");

            if (gl === null) {
                console.error("Unable to initialize WebGL");
                return;
            }


            // Load shaders
            const vsSource = await loadShader('shaders/vertex.glsl');
            const fsSource = await loadShader('shaders/fragment.glsl');

            // Initialize shader program
            const shaderProgram = initShaderProgram(gl, vsSource, fsSource);

            // Store locations of uniforms
            const programInfo = {
                uniforms: {
                    time: gl.getUniformLocation(shaderProgram, 'uTime'),
                    radius: gl.getUniformLocation(shaderProgram, 'uRadius'),
                    matrix: gl.getUniformLocation(shaderProgram, 'u_matrix'),
                },
                attribs: {
                    position: gl.getAttribLocation(shaderProgram, 'a_position'),
                    color: gl.getAttribLocation(shaderProgram, 'a_color'),
                }
            };


            var fieldOfViewRadians = degToRad(60);
            var cameraAngleRadians = degToRad(0);
            var numFs = 5;
            var radius = 200;

            var fPosition = [radius, 0, 0];


            // Setup controls

            const fieldOfViewControl = document.getElementById('fieldOfViewControl');
            const fieldOfViewValue = document.getElementById('fieldOfViewValue');

            const cameraAngleControl = document.getElementById('cameraAngleControl');
            const cameraAngleValue = document.getElementById('cameraAngleValue');


            fieldOfViewControl.addEventListener('input', (event) => {
                fieldOfViewValue.value = parseFloat(event.target.value, 10);
                fieldOfViewValue.textContent = event.target.value;
                fieldOfViewRadians = fieldOfViewValue.value * Math.PI / 180.;
            });
            cameraAngleControl.addEventListener('input', (event) => {
                cameraAngleValue.value = parseFloat(event.target.value, 10);
                cameraAngleValue.textContent = event.target.value;
                cameraAngleRadians = cameraAngleValue.value * Math.PI / 180.;
            });


            // Create and bind buffer
            const vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);

            const colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            setColors(gl);



            // Initialize FPS counter
            const fpsCounter = new FPSCounter();

            // Animation function
            function render(time) {
                time *= 0.001; // Convert to seconds

                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
                gl.clearColor(0.0, 0.0, 0.0, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                gl.enable(gl.CULL_FACE);
                gl.enable(gl.DEPTH_TEST);

                gl.useProgram(shaderProgram);


                // Update uniforms
                gl.uniform1f(programInfo.uniforms.time, time);

                // Camera Generation
                console.log(cameraAngleRadians);
                var cameraMatrix = m4.yRotation(cameraAngleRadians);
                cameraMatrix = m4.translate(cameraMatrix, 0, 0, radius * 1.5);

                var cameraPosition = [
                    cameraMatrix[12],
                    cameraMatrix[13],
                    cameraMatrix[14],
                ];


                var up = [0, 1, 0];

                var cameraMatrix = m4.lookAt(cameraPosition, fPosition, up);

                var viewMatrix = m4.inverse(cameraMatrix);


                var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
                var zNear = 1;
                var zFar = 2000;
                var projectionMatrix = m4.perspective(fieldOfViewRadians, aspect, zNear, zFar);

                var viewProjectionMatrix = m4.multiply(projectionMatrix, viewMatrix);


                // Set up vertex attributes
                gl.enableVertexAttribArray(programInfo.attribs.position);
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                set3DGeometry(gl);

                gl.vertexAttribPointer(
                    programInfo.attribs.position,
                    3,          // 2 components per vertex
                    gl.FLOAT,   // data type
                    false,      // don't normalize
                    0,          // stride
                    0           // offset
                );

                gl.enableVertexAttribArray(programInfo.attribs.color);
                gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);

                const size = 3;
                const type = gl.UNSIGNED_BYTE;
                const normalize = true;
                const stride = 0;
                const offset = 0;

                gl.vertexAttribPointer(programInfo.attribs.color, size, type, normalize, stride, offset);

                // Scene Rendering  

                for (var ii = 0; ii < numFs; ++ii) {
                    var angle = ii * Math.PI * 2 / numFs;
                    var x = Math.cos(angle) * radius;
                    var y = Math.sin(angle) * radius;

                    // starting with the view projection matrix
                    // compute a matrix for the F
                    var matrix = m4.translate(viewProjectionMatrix, x, 0, y);

                    // Set the matrix.
                    gl.uniformMatrix4fv(programInfo.uniforms.matrix, false, matrix);

                    // Draw the geometry.
                    var primitiveType = gl.TRIANGLES;
                    var count = 16 * 6;
                    gl.drawArrays(primitiveType, 0, count);
                }
                // Draw the triangle


                // Update FPS counter
                fpsCounter.update();

                requestAnimationFrame(render);
            }

            requestAnimationFrame(render);
        }

        window.onload = main;
    </script>
</body>

</html>
