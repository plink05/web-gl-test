<!DOCTYPE html>
<html>

<head>
    <title>Moving WebGL Triangle</title>
    <style>
        canvas {
            border: 1px solid black;
        }

        #fps {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 3px;
            font-family: monospace;
        }

        #controls {
            position: fixed;
            top: 50px;
            left: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 3px;
            font-family: monospace;
        }

        label {
            display: block;
            margin: 5px 0;
        }
    </style>
</head>

<body>
    <div id="fps">FPS: 0</div>
    <div id="controls">
        <label>
            X:
            <input type="range" id="xControl" min="-200" max="200" step="1" value="0.0">
            <span id="xValue">0.0</span>
        </label>
        <label>
            Y:
            <input type="range" id="yControl" min="-200" max="200" step="1" value="0.0">
            <span id="yValue">0.0</span>
        </label>
        <label>
            z:
            <input type="range" id="zControl" min="-1000" max="0" step="1" value="0.0">
            <span id="zValue">0.0</span>
        </label>
        <label>
            xScale:
            <input type="range" id="xScaleControl" min="0" max="3.0" step="0.1" value="1.0">
            <span id="xScaleValue">1.0</span>
        </label>
        <label>
            yScale:
            <input type="range" id="yScaleControl" min="0" max="3.0" step="0.1" value="1.0">
            <span id="yScaleValue">1.0</span>
        </label>
        <label>
            zScale:
            <input type="range" id="zScaleControl" min="0" max="3.0" step="0.1" value="1.0">
            <span id="zScaleValue">1.0</span>
        </label>
        <label>
            xRotation:
            <input type="range" id="xRotationControl" min="0" max="360" step="0.1" value="0.0">
            <span id="xRotationValue">0.0</span>
        </label>
        <label>
            yRotation:
            <input type="range" id="yRotationControl" min="0" max="360" step="0.1" value="0.0">
            <span id="yRotationValue">0.0</span>
        </label>
        <label>
            zRotation:
            <input type="range" id="zRotationControl" min="0" max="360" step="0.1" value="0.0">
            <span id="zRotationValue">0.0</span>
        </label>
        <label>
            fieldOfView:
            <input type="range" id="fieldOfViewControl" min="0" max="180.0" step="0.1" value="30.0">
            <span id="fieldOfViewValue">0.0</span>
        </label>
    </div>
    <canvas id="glCanvas" width="640" height="480"></canvas>
    <script type="module">

        import {setColors, degToRad, m4, getXYRotation, set3DGeometry, setRectangle} from "./math/utils.js";

        import {loadShader, initShaderProgram, compileShader} from "./webgl/mod.js";

        class FPSCounter {
            constructor() {
                this.fps = 0;
                this.frames = 0;
                this.lastTime = performance.now();
                this.element = document.getElementById('fps');
            }

            update() {
                this.frames++;
                const currentTime = performance.now();
                const elapsed = currentTime - this.lastTime;

                if (elapsed >= 1000) {
                    this.fps = Math.round((this.frames * 1000) / elapsed);
                    this.frames = 0;
                    this.lastTime = currentTime;
                    this.element.textContent = `FPS: ${this.fps}`;
                }
            }
        }

        async function main() {
            const canvas = document.querySelector("#glCanvas");
            const gl = canvas.getContext("webgl");

            if (gl === null) {
                console.error("Unable to initialize WebGL");
                return;
            }


            // Load shaders
            const vsSource = await loadShader('shaders/vertex.glsl');
            const fsSource = await loadShader('shaders/fragment.glsl');

            // Initialize shader program
            const shaderProgram = initShaderProgram(gl, vsSource, fsSource);

            // Store locations of uniforms
            const programInfo = {
                uniforms: {
                    time: gl.getUniformLocation(shaderProgram, 'uTime'),
                    radius: gl.getUniformLocation(shaderProgram, 'uRadius'),
                    matrix: gl.getUniformLocation(shaderProgram, 'u_matrix'),
                },
                attribs: {
                    position: gl.getAttribLocation(shaderProgram, 'a_position'),
                    color: gl.getAttribLocation(shaderProgram, 'a_color'),
                }
            };

            var translation = [-150, 0, -360];
            var rotation = [degToRad(190), degToRad(40), degToRad(320)];
            var scale = [1, 1, 1];

            var fieldOfViewRadians = degToRad(60);

            // Setup controls
            const xControl = document.getElementById('xControl');
            const xValue = document.getElementById('xValue');
            const yControl = document.getElementById('yControl');
            const yValue = document.getElementById('yValue');
            const zControl = document.getElementById('zControl');
            const zValue = document.getElementById('zValue');

            const xRotationControl = document.getElementById('xRotationControl');
            const xRotationValue = document.getElementById('xRotationValue');
            const yRotationControl = document.getElementById('yRotationControl');
            const yRotationValue = document.getElementById('yRotationValue');
            const zRotationControl = document.getElementById('zRotationControl');
            const zRotationValue = document.getElementById('zRotationValue');

            const xScaleControl = document.getElementById('xScaleControl');
            const xScaleValue = document.getElementById('xScaleValue');
            const yScaleControl = document.getElementById('yScaleControl');
            const yScaleValue = document.getElementById('yScaleValue');
            const zScaleControl = document.getElementById('zScaleControl');
            const zScaleValue = document.getElementById('zScaleValue');

            const fieldOfViewControl = document.getElementById('fieldOfViewControl');
            const fieldOfViewValue = document.getElementById('fieldOfViewValue');



            xControl.addEventListener('input', (event) => {
                xValue.value = parseInt(event.target.value, 10);
                xValue.textContent = event.target.value;
                translation[0] = xValue.value;
            });
            yControl.addEventListener('input', (event) => {
                yValue.value = parseInt(event.target.value, 10);
                yValue.textContent = event.target.value;
                translation[1] = yValue.value;
            });
            zControl.addEventListener('input', (event) => {
                zValue.value = parseFloat(event.target.value, 10);
                zValue.textContent = event.target.value;
                translation[2] = zValue.value;
            });
            xScaleControl.addEventListener('input', (event) => {
                xScaleValue.value = parseFloat(event.target.value, 10);
                xScaleValue.textContent = event.target.value;
                scale[0] = xScaleValue.value;
            });
            yScaleControl.addEventListener('input', (event) => {
                yScaleValue.value = parseFloat(event.target.value, 10);
                yScaleValue.textContent = event.target.value;
                scale[1] = yScaleValue.value;
            });
            zScaleControl.addEventListener('input', (event) => {
                zScaleValue.value = parseFloat(event.target.value, 10);
                zScaleValue.textContent = event.target.value;
                scale[2] = zScaleValue.value;
            });
            xRotationControl.addEventListener('input', (event) => {
                xRotationValue.value = parseFloat(event.target.value, 10);
                xRotationValue.textContent = event.target.value;
                rotation[0] = xRotationValue.value * Math.PI / 180.
            });
            yRotationControl.addEventListener('input', (event) => {
                yRotationValue.value = parseFloat(event.target.value, 10);
                yRotationValue.textContent = event.target.value;
                rotation[1] = yRotationValue.value * Math.PI / 180.
            });
            zRotationControl.addEventListener('input', (event) => {
                zRotationValue.value = parseFloat(event.target.value, 10);
                zRotationValue.textContent = event.target.value;
                rotation[2] = zRotationValue.value * Math.PI / 180.
            });
            fieldOfViewControl.addEventListener('input', (event) => {
                fieldOfViewValue.value = parseFloat(event.target.value, 10);
                fieldOfViewValue.textContent = event.target.value;
                fieldOfViewRadians = fieldOfViewValue.value * Math.PI / 180.;
            });


            // Create and bind buffer
            const vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);

            const colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            setColors(gl);



            // Initialize FPS counter
            const fpsCounter = new FPSCounter();


            // Animation function
            function render(time) {
                time *= 0.001; // Convert to seconds

                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
                gl.clearColor(0.0, 0.0, 0.0, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                gl.enable(gl.CULL_FACE);
                gl.enable(gl.DEPTH_TEST);

                gl.useProgram(shaderProgram);


                // Update uniforms
                gl.uniform1f(programInfo.uniforms.time, time);
                var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
                var zNear = 1;
                var zFar = 2000;
                var matrix = m4.perspective(fieldOfViewRadians, aspect, zNear, zFar);
                matrix = m4.translate(matrix, translation[0], translation[1], translation[2]);
                matrix = m4.xRotate(matrix, rotation[0]);
                matrix = m4.yRotate(matrix, rotation[1]);
                matrix = m4.zRotate(matrix, rotation[2]);
                matrix = m4.scale(matrix, scale[0], scale[1], scale[2]);

                // var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
                // var zNear = 1;
                // var zFar = 2000;
                // var matrix = m4.perspective(fieldOfViewRadians, aspect, zNear, zFar);
                // console.log(fieldOfViewRadians);
                // console.log(matrix);
                // var left = 0;
                // var right = gl.canvas.clientWidth;
                // var bottom = gl.canvas.clientHeight;
                // var top = 0;
                // var near = 400;
                // var far = -400;
                // // var matrix = m4.orthographic(left, right, bottom, top, near, far);
                // // console.log(matrix);

                // matrix = m4.translate(matrix, translation[0], translation[1], translation[2]);
                // matrix = m4.xRotate(matrix, rotation[0]);
                // matrix = m4.yRotate(matrix, rotation[1]);
                // matrix = m4.zRotate(matrix, rotation[2]);
                // matrix = m4.scale(matrix, scale[0], scale[1], scale[2]);
                gl.uniformMatrix4fv(programInfo.uniforms.matrix, false, matrix);

                // Set up vertex attributes
                gl.enableVertexAttribArray(programInfo.attribs.position);
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                set3DGeometry(gl);

                gl.vertexAttribPointer(
                    programInfo.attribs.position,
                    3,          // 2 components per vertex
                    gl.FLOAT,   // data type
                    false,      // don't normalize
                    0,          // stride
                    0           // offset
                );

                gl.enableVertexAttribArray(programInfo.attribs.color);
                gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);

                const size = 3;
                const type = gl.UNSIGNED_BYTE;
                const normalize = true;
                const stride = 0;
                const offset = 0;

                gl.vertexAttribPointer(programInfo.attribs.color, size, type, normalize, stride, offset);

                // Draw the triangle
                gl.drawArrays(gl.TRIANGLES, 0, 16 * 6);


                // Update FPS counter
                fpsCounter.update();

                requestAnimationFrame(render);
            }

            requestAnimationFrame(render);
        }

        window.onload = main;
    </script>
</body>

</html>
